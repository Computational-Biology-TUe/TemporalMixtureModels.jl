var documenterSearchIndex = {"docs":
[{"location":"tutorials/multivariate/#Multivariate-Model","page":"Multivariate","title":"Multivariate Model","text":"","category":"section"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"In this section, we will demonstrate how to fit a multivariate temporal mixture model using the TemporalMixtureModels.jl package. We will use synthetic data for this example.","category":"page"},{"location":"tutorials/multivariate/#Prerequisites","page":"Multivariate","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"While the package uses an internal data structure for the time series data, the package by default implements automatic conversion from a DataFrame to its internal format. ","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"using TemporalMixtureModels, DataFrames","category":"page"},{"location":"tutorials/multivariate/#Generating-Synthetic-Data","page":"Multivariate","title":"Generating Synthetic Data","text":"","category":"section"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"We will generate some synthetic multivariate time series data. The data will consist of two variables, each generated from different polynomial functions with added Gaussian noise. The input DataFrame should be a so-called \"long\" format, with columns for the individual ID, time points, variable names, and observed values.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"# Set random seed for reproducibility\nusing Random\nRandom.seed!(1234)\n\n# Generate time points\nindividuals_per_group = [20, 30]\nt_values = 0:0.1:10\nn_groups = 2\n\ngroup_coefficients_y = [ [2.0, -0.5, 0.05],  # Group 1: y = 2 - 0.5*t + 0.05*t^2\n                       [1.0, 0.3, -0.02] ] # Group 2: y = 1 + 0.3*t - 0.02*t^2\ngroup_coefficients_z = [ [0.5, 0.4, -0.03],  # Group 1: z = 0.5 + 0.4*t - 0.03*t^2\n                       [3.0, -0.2, 0.04] ] # Group 2: z = 3 - 0.2*t + 0.04*t^2\n\nids = Int[]\ntimepoints = Float64[]\nmeasurements_y = Float64[]\nmeasurements_z = Float64[]\nfor group in 1:n_groups\n    id_start = sum(individuals_per_group[1:group-1]) + 1\n    id_end = sum(individuals_per_group[1:group])\n    for individual in id_start:id_end\n        for t in t_values\n            y = group_coefficients_y[group][1] + group_coefficients_y[group][2]*t + group_coefficients_y[group][3]*t^2 + randn()*0.25\n            z = group_coefficients_z[group][1] + group_coefficients_z[group][2]*t + group_coefficients_z[group][3]*t^2 + randn()*0.25\n            push!(ids, individual)\n            push!(timepoints, t)\n            push!(measurements_y, y)\n            push!(measurements_z, z)\n        end\n    end\nend\n\ninput_data = DataFrame(id = [ids; ids], time = [timepoints; timepoints], value = [measurements_y; measurements_z], var_name = repeat([\"y\", \"z\"], inner=length(ids)))\nfirst(input_data, 5)  # Display the first 5 rows of the DataFrame","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"Here you can see the first few rows of the generated DataFrame. Each row corresponds to a measurement for a specific individual at a specific time point for one of the two variables.","category":"page"},{"location":"tutorials/multivariate/#Fitting-a-Multivariate-Temporal-Mixture-Model","page":"Multivariate","title":"Fitting a Multivariate Temporal Mixture Model","text":"","category":"section"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"Now that we have our synthetic multivariate data, we can fit a multivariate temporal mixture model using the fit! function. We will use polynomial regression models as the component models for this example. We will specify the number of components (clusters) we expect in the data.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"We first define the model, specifying the number of components and the type of component models to use for each variable. In this case, we will use polynomial regression models of degree 2 for both variables.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"# Define the number of components and the component models for each variable\nn_components = 2\ncomponent_models = Dict(:y => PolynomialRegression(2), :z => PolynomialRegression(2))\nmodel = MultivariateMixtureModel(n_components, component_models)","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"We can now fit the model to our data using the fit! function. This function takes the model and the input DataFrame as arguments and performs the fitting process.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"# Fit the model to the data\nfit!(model, input_data)","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"As with the univariate case, we can also estimate the uncertainty of the fitted model parameters using the bootstrap_ci function. This function performs bootstrap resampling to compute confidence intervals for the model parameters.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"# Compute bootstrap confidence intervals\nn_bootstrap = 100  # Number of bootstrap samples\nconfidence_intervals, _, _ = bootstrap_ci(model, input_data; n_bootstrap=n_bootstrap)\nconfidence_intervals","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"The output shows the confidence intervals for the parameters of each component model and variable in the mixture. We can use these intervals and the fitted model to visualize the results.","category":"page"},{"location":"tutorials/multivariate/","page":"Multivariate","title":"Multivariate","text":"using CairoMakie\n\n# Create a range of time points for prediction\nt_pred = 0:0.1:10\n\n# Prepare a figure\nfigure_mixture = let f = Figure()\n\n    # Plot the fitted component models\n    predictions = predict(model, t_pred)\n\n    COMPONENT_COLORS = [colorant\"#c74300\", colorant\"#008aa1\"]\n\n    for (axi, variable) in enumerate([:y, :z])\n        ax = Axis(f[1, axi], xlabel=\"Time\", ylabel=\"Value\", title=\"Temporal Mixture, variable: $variable\")\n        # Plot the original data points\n        scatter!(ax, input_data[input_data[!,:var_name] .== String(variable),:time], input_data[input_data[!,:var_name] .== String(variable),:value]; color=:gray, markersize=2, label=\"Data - $variable\")\n        for k in axes(predictions[variable], 2)\n            lines!(ax, t_pred, predictions[variable][:, k]; \n            label=\"Component $k - $variable\", color=COMPONENT_COLORS[k], linewidth=2)\n\n            # get the confidence bounds. This is still a bit clunky because there is no API for this yet\n            lower_bound_parameters = confidence_intervals[k][variable][:lower]\n            upper_bound_parameters = confidence_intervals[k][variable][:upper]\n\n            model_lb = PolynomialRegression(2, lower_bound_parameters)\n            model_ub = PolynomialRegression(2, upper_bound_parameters)\n\n            y_lower = predict(model_lb, t_pred)\n            y_upper = predict(model_ub, t_pred)\n\n            # Plot the confidence intervals as shaded areas\n            band!(ax, t_pred, y_lower, y_upper; \n            color=(COMPONENT_COLORS[k], 0.3), label=\"Component $k - $variable\")\n        end\n    end\n\n    f\nend\nfigure_mixture","category":"page"},{"location":"api/components/#Model-Components","page":"Model Components","title":"Model Components","text":"","category":"section"},{"location":"api/components/#Polynomial-Regression","page":"Model Components","title":"Polynomial Regression","text":"","category":"section"},{"location":"api/components/","page":"Model Components","title":"Model Components","text":"The PolynomialRegression model fits a polynomial of a specified degree to the time series data.","category":"page"},{"location":"api/components/#TemporalMixtureModels.PolynomialRegression-Tuple{Int64}","page":"Model Components","title":"TemporalMixtureModels.PolynomialRegression","text":"Create a polynomial regression mixture model component of specified degree.\n\nArguments\n\ndegree::Int: Degree of the polynomial.\n\nExample\n\nCreating a polynomial regression model of degree 2:\n\nmodel = PolynomialRegression(2)\n\n\n\n\n\n","category":"method"},{"location":"api/components/#Ridge-Regression","page":"Model Components","title":"Ridge Regression","text":"","category":"section"},{"location":"api/components/","page":"Model Components","title":"Model Components","text":"The Ridge model fits a polynomial regression with L2 regularization (ridge regression)","category":"page"},{"location":"api/components/#TemporalMixtureModels.RidgePolynomialRegression-Tuple{Int64, Any}","page":"Model Components","title":"TemporalMixtureModels.RidgePolynomialRegression","text":"Create a ridge (L2) polynomial regression mixture model component of specified degree and regularization parameter.\n\nArguments\n\ndegree::Int: Degree of the polynomial.\nlambda::T: Regularization parameter (L2 penalty).\n\nExample\n\nCreating a ridge polynomial regression model of degree 2 with lambda = 0.1:\n\nmodel = RidgePolynomialRegression(2, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/components/#Lasso-Regression","page":"Model Components","title":"Lasso Regression","text":"","category":"section"},{"location":"api/components/","page":"Model Components","title":"Model Components","text":"The Lasso model fits a polynomial regression with L1 regularization (lasso regression)","category":"page"},{"location":"api/components/#TemporalMixtureModels.LassoPolynomialRegression-Tuple{Int64, Any}","page":"Model Components","title":"TemporalMixtureModels.LassoPolynomialRegression","text":"Create a lasso (L1) polynomial regression mixture model component of specified degree and regularization parameter.\n\nArguments\n\ndegree::Int: Degree of the polynomial.\nlambda::T: Regularization parameter (L1 penalty).\n\nExample\n\nCreating a lasso polynomial regression model of degree 2 with lambda = 0.1:\n\nmodel = LassoPolynomialRegression(2, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/components/#Custom-Models","page":"Model Components","title":"Custom Models","text":"","category":"section"},{"location":"api/components/","page":"Model Components","title":"Model Components","text":"Custom model components can be implemented by subtyping the AbstractMixtureModelComponent and implementing the required methods. This allows for flexibility in defining new model types and behaviors tailored to specific use cases. See the tutorial on Implementing Custom Components for how to create your own model components.","category":"page"},{"location":"tutorials/custom/#Implementing-Custom-Components","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"","category":"section"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"This tutorial demonstrates how to create custom model components by subtyping the AbstractMixtureModelComponent and implementing the required methods. This allows for flexibility in defining new model types and behaviors tailored to specific use cases. In this example, we will create an ODE model component using the OrdinaryDiffEq.jl package and optimize its parameters using Optim.jl.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"Load the necessary packages:","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"using OrdinaryDiffEq, CairoMakie, TemporalMixtureModels, DataFrames, Optim, Random","category":"page"},{"location":"tutorials/custom/#Generating-some-synthetic-data","page":"Implementing Custom Components","title":"Generating some synthetic data","text":"","category":"section"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"In this tutorial, the ODE model that we will use is based on a simple decay process defined by the differential equation:","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"fracmathrmdumathrmdt = -k u","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"where k is the decay constant, and we have an initial condition u(0) = u_0. While we can analytically solve this ODE, we will use a numerical solver to demonstrate how to integrate ODE solving into a custom model component.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"We will generate synthetic data by simulating this decay process with added Gaussian noise. The input DataFrame should be a so-called \"long\" format, with columns for the individual ID, time points, and observed values. First, we define functions to simulate the decay process and generate synthetic data for multiple individuals.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"# Set random seed for reproducibility\nRandom.seed!(1234)\n\nfunction decay_ode!(du, u, p, t)\n    k = p[1]\n    du[1] = -k * u[1]\nend\n\nfunction simulate_decay(p, u0, t; noise_std=0.1)\n    prob = ODEProblem(decay_ode!, u0, (t[1], t[end]), p)\n    sol = solve(prob, Tsit5(), saveat=t)\n    noisy_data = sol .+ noise_std * randn(length(t))\n    return noisy_data\nend\n\nfunction simulate_group(p_mean, p_std, u0_mean, u0_std, t, n_individuals, id_start=1; noise_std=0.1)\n    p = p_mean .+ randn(n_individuals) .* p_std\n    u0 = u0_mean .+ randn(n_individuals) .* u0_std\n\n    values = Float64[]\n    time = Float64[]\n    ids = Int[]\n    for (i, id) in enumerate(id_start:(id_start + n_individuals - 1))\n        data = Array(simulate_decay([p[i]], [u0[i]], t; noise_std=noise_std))[1,:]\n        append!(values, data)\n        append!(time, t)\n        append!(ids, fill(id, length(t)))\n    end\n    return DataFrame(id=ids, time=time, value=values)\nend","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"We can now generate synthetic data for three groups of individuals, each with different decay constants and initial conditions.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"# simulate three groups\ntime_points = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\ngroup1 = simulate_group(0.5, 0.05, 5.0, 0.5, time_points, 30)\ngroup2 = simulate_group(1.0, 0.1, 3.0, 0.3, time_points, 15, 31)\ngroup3 = simulate_group(1.5, 0.15, 1.0, 0.2, time_points, 45, 46)\ndata = vcat(group1, group2, group3)\nfirst(data, 5)  # Display the first 5 rows of the DataFrame","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"Here you can see the first few rows of the generated DataFrame. Each row corresponds to a measurement for a specific individual at a specific time point.","category":"page"},{"location":"tutorials/custom/#Defining-the-Custom-ODE-Model-Component","page":"Implementing Custom Components","title":"Defining the Custom ODE Model Component","text":"","category":"section"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"We will now define a custom model component by subtyping the AbstractMixtureModelComponent.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"mutable struct DecayODE{T<:Real} <: TemporalMixtureModels.AbstractMixtureModelComponent{T}\n    coefficients::Vector{T}  # [k, u0]\n    function DecayODE(p::T, u0::T) where T<:Real\n        new{T}([p, u0])\n    end\nend\n\nfunction DecayODE()\n    DecayODE(1.0, 1.0)\nend","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"The DecayODE struct holds the parameters of the ODE model, specifically the decay constant k and the initial condition u_0. The coefficients field is mandatory for all model components, as it is used in the fitting process.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"Next, we need to implement four essential methods for our custom model component: predict(::DecayODE, t), randinit!(::DecayODE), fit!(::DecayODE, t, y), and fit!(::DecayODE, t, y, w).","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"function TemporalMixtureModels.predict(m::DecayODE, t)\n    p, u0 = m.coefficients\n    prob = ODEProblem(decay_ode!, [u0], (minimum(t), maximum(t)), [p])\n\n    # argsort t\n    sorted_indices = sortperm(t)\n\n    sol = Array(solve(prob, Tsit5(), saveat=t))[:]\n\n    # count the number of time points where t == minimum(t), and add those to the start of sol (n - 1) times\n    n = count(x -> x == minimum(t), t)\n    if n > 1\n        sol = vcat(fill(sol[1], n - 1), sol)\n    end\n\n    try\n        return sol[invperm(sorted_indices)]\n    catch\n        return sol\n    end\nend\n\nfunction TemporalMixtureModels.randinit!(m::DecayODE)\n    m.coefficients = [rand(0.1:0.1:2.0), rand(0.5:0.5:6.0)]\nend\n\nfunction TemporalMixtureModels.fit!(m::DecayODE, t, y)\n    function loss(p)\n        y_hat = TemporalMixtureModels.predict(DecayODE(p[1], p[2]), t)\n        if length(y_hat) != length(y)\n            return Inf\n        end\n        return sum(abs2, y_hat .- y)\n    end\n    result = Optim.minimizer(optimize(loss, [0.0, 0.0], [10.0,10.0], m.coefficients, Fminbox(BFGS()), autodiff=:forward))\n    m.coefficients = result\nend\n\nfunction TemporalMixtureModels.fit!(m::DecayODE, t, y, weights)\n    function loss(p)\n        y_hat = TemporalMixtureModels.predict(DecayODE(p[1], p[2]), t)\n        if length(y_hat) != length(y)\n            return Inf\n        end\n        return sum(weights .* (y_hat .- y).^2)\n    end\n    result = Optim.minimizer(optimize(loss, [0.0, 0.0], [10.0,10.0], m.coefficients, Fminbox(BFGS()), autodiff=:forward))\n    m.coefficients = result\nend","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"The predict function uses the OrdinaryDiffEq.jl package to solve the ODE numerically for given time points. The randinit! function initializes the model parameters randomly within specified ranges. The fit! functions optimize the model parameters to minimize the squared error between the predicted and observed values, with and without weights.","category":"page"},{"location":"tutorials/custom/#Fitting-the-Custom-Model-Component","page":"Implementing Custom Components","title":"Fitting the Custom Model Component","text":"","category":"section"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"After defining the custom model component, we can now fit a temporal mixture model using our DecayODE component.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"mm = UnivariateMixtureModel(3, DecayODE())\nTemporalMixtureModels.fit!(mm, data)","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"Similarly, we can also use the bootstrap method to estimate confidence intervals for the model parameters.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"n_bootstrap = 50  # Number of bootstrap samples\nconfidence_intervals, _, _ = bootstrap_ci(mm, data; n_bootstrap=n_bootstrap)\nconfidence_intervals","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"The output shows the confidence intervals for the parameters of each component model in the mixture. We can use these intervals and the fitted model to visualize the results.","category":"page"},{"location":"tutorials/custom/","page":"Implementing Custom Components","title":"Implementing Custom Components","text":"# Create a range of time points for prediction\nt_pred = 0:0.1:3.0\n\n# Prepare a figure\nfigure_mixture = let f = Figure()\n    ax = Axis(f[1, 1], xlabel=\"Time\", ylabel=\"Value\", title=\"Temporal Mixture Model Fit\")\n\n    # Plot the original data points\n    scatter!(ax, data.time, data.value; color=:gray, markersize=4, label=\"Data\")\n\n    # Plot the fitted component models\n    predictions = predict(mm, t_pred)\n\n    COMPONENT_COLORS = [colorant\"#c74300\", colorant\"#008aa1\", colorant\"#ffc300\"]\n\n    for k in axes(predictions, 2)\n        lines!(ax, t_pred, predictions[:, k]; \n        label=\"Component $k\", color=COMPONENT_COLORS[k], linewidth=2)\n\n        # get the confidence bounds. This is still a bit clunky because there is no API for this yet\n        lower_bound_parameters = confidence_intervals[k][:lower]\n        upper_bound_parameters = confidence_intervals[k][:upper]\n\n        # sample 5000 random parameter sets within the confidence bounds\n        random_parameters = [[rand() * (upper_bound_parameters[i] - lower_bound_parameters[i]) + lower_bound_parameters[i] for i in eachindex(lower_bound_parameters)] for _ in 1:5000]\n\n        models = [DecayODE(p[1], p[2]) for p in random_parameters]\n        predictions_ci = [predict(m, t_pred) for m in models]\n        y_lower = map(t -> minimum([pred[t] for pred in predictions_ci]), 1:length(t_pred))\n        y_upper = map(t -> maximum([pred[t] for pred in predictions_ci]), 1:length(t_pred))\n\n        # Plot the confidence intervals as shaded areas\n        band!(ax, t_pred, y_lower, y_upper; \n        color=(COMPONENT_COLORS[k], 0.2), label=\"Component $k\")\n    end\n\n    axislegend(ax; merge=true)\n\n    f\nend","category":"page"},{"location":"api/fitting/#Fitting-Models-and-Estimating-Uncertainty","page":"Fitting Models","title":"Fitting Models and Estimating Uncertainty","text":"","category":"section"},{"location":"api/fitting/","page":"Fitting Models","title":"Fitting Models","text":"The primary function for fitting temporal mixture models is fit!. This function takes a mixture model and a dataset as input and performs the fitting process using the Expectation-Maximization (EM) algorithm. The function modifies the input model in place, updating its parameters to best fit the data.","category":"page"},{"location":"api/fitting/#TemporalMixtureModels.fit!","page":"Fitting Models","title":"TemporalMixtureModels.fit!","text":"Fit a mixture model to the given DataFrame.\n\nUsage\n\nfit!(model, df, [id_col], [time_col], [value_col], [var_name_col]; kwargs...)\n\nArguments\n\nmodel::AbstractMixtureModel: The mixture model to fit.\ndf::DataFrame: The input data.\n\nOptional Keyword Arguments\n\nid_col::String=\"id\": The name of the column containing individual IDs.\ntime_col::String=\"time\": The name of the column containing time points.\nvalue_col::String=\"value\": The name of the column containing observed values.\nvar_name_col::String=\"var_name\": The name of the column containing variable, can be ignored for univariate data.\nkwargs...: Additional keyword arguments passed to the internal fit! function.\n\nExample\n\nmodel = UnivariateMixtureModel(2, PolynomialRegression(2))\nfit!(model, df)\n\n\n\n\n\n","category":"function"},{"location":"api/fitting/#Additional-keyword-arguments-used-by-fit!","page":"Fitting Models","title":"Additional keyword arguments used by fit!","text":"","category":"section"},{"location":"api/fitting/","page":"Fitting Models","title":"Fitting Models","text":"rng: An optional random number generator for reproducibility. Default is Random.default_rng().\nverbose: A boolean flag to control the verbosity of the fitting process. Default is true.\nmax_iter: The maximum number of iterations for the EM algorithm. Default is 100.\ntol: The tolerance for convergence. The fitting process stops when the change in log-likelihood is less than this value. Default is 1e-6.\nhard_assignment: A boolean flag indicating whether to use hard assignments (True) or soft assignments (False) during the E-step of the EM algorithm. Default is false.","category":"page"},{"location":"api/fitting/#Evaluating-Model-Fit","page":"Fitting Models","title":"Evaluating Model Fit","text":"","category":"section"},{"location":"api/fitting/","page":"Fitting Models","title":"Fitting Models","text":"To evaluate the fit of a temporal mixture model, the package provides functions to compute the log-likelihoods and posterior responsibilities.","category":"page"},{"location":"api/fitting/#TemporalMixtureModels.log_likelihood","page":"Fitting Models","title":"TemporalMixtureModels.log_likelihood","text":"Compute the total log-likelihood of the mixture model for the given DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/fitting/#TemporalMixtureModels.posterior_responsibilities","page":"Fitting Models","title":"TemporalMixtureModels.posterior_responsibilities","text":"Compute posterior responsibilities for the given DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/fitting/#Bootstrap-Confidence-Intervals","page":"Fitting Models","title":"Bootstrap Confidence Intervals","text":"","category":"section"},{"location":"api/fitting/","page":"Fitting Models","title":"Fitting Models","text":"To estimate the uncertainty of the fitted model parameters, the package provides a bootstrap_ci function. This function performs bootstrap resampling to compute confidence intervals for the model parameters.","category":"page"},{"location":"api/fitting/#TemporalMixtureModels.bootstrap_ci","page":"Fitting Models","title":"TemporalMixtureModels.bootstrap_ci","text":"Run bootstrap resampling to estimate confidence intervals for the coefficients of each component in a mixture model.\n\nArguments\n\nmodel::AbstractMixtureModel{T}: The fitted mixture model\ndf::DataFrame: The input DataFrame containing the data.\n\nOptional keyword arguments\n\nn_bootstrap::Int=100: Number of bootstrap samples to draw.\nalpha::Float64=0.05: Significance level for the confidence intervals (e.g., 0.05 for 95% CI).\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator to use.\nprog::Bool=true: Whether to show a progress bar.\n\nReturns\n\nIn case of a univariate mixture model\n\nci_results::Vector{Dict{Symbol, Any}}: A vector where each element corresponds to a component and contains a dictionary with keys :lower and :upper for the confidence intervals of the coefficients.\ncomponent_samples::Vector{Vector{Vector{T}}}: A vector where each element corresponds to a component and contains a vector of coefficient samples from the bootstrap resampling.\nambiguities_detected::Int: The number of ambiguities detected during component matching in the bootstrap resampling. A high number may indicate unreliable confidence intervals due to uncertain sample assignment to components.\n\nIn case of a multivariate mixture model\n\nci_results::Vector{Dict{Symbol, Any}}: A vector where each element corresponds to a component and contains a dictionary. Each dictionary has variable names as keys and values are tuples with keys :lower and :upper for the confidence intervals of the coefficients for that variable.\ncomponent_samples::Vector{Dict{Symbol, Vector{Vector{T}}}}: A vector where each element corresponds to a component and contains a dictionary. Each dictionary has variable names as keys and values are vectors of coefficient samples from the bootstrap resampling for that variable.\nambiguities_detected::Int: The number of ambiguities detected during component matching in the bootstrap resampling. A high number may indicate unreliable confidence intervals due to uncertain sample assignment to components.\n\n\n\n\n\n","category":"function"},{"location":"api/mixtures/#Mixture-Models","page":"Mixture Models","title":"Mixture Models","text":"","category":"section"},{"location":"api/mixtures/","page":"Mixture Models","title":"Mixture Models","text":"A mixture model is a probabilistic model that assumes that the observed data is generated from a mixture of several underlying distributions, each representing a different component of the data. In the context of temporal mixture models, each component is a temporal regression model that captures the underlying patterns in the time series data.","category":"page"},{"location":"api/mixtures/#Univariate-Mixture-Model","page":"Mixture Models","title":"Univariate Mixture Model","text":"","category":"section"},{"location":"api/mixtures/","page":"Mixture Models","title":"Mixture Models","text":"The UnivariateMixtureModel is designed for clustering univariate time series data. It consists of multiple component models, each representing a different cluster in the data.","category":"page"},{"location":"api/mixtures/#TemporalMixtureModels.UnivariateMixtureModel","page":"Mixture Models","title":"TemporalMixtureModels.UnivariateMixtureModel","text":"Create a univariate mixture model with n_components where each component is defined as the model passed in component. \n\nArguments\n\nn_components::Int: Number of mixture components. \ncomponent::AbstractMixtureModelComponent{T}: An instance of a component model (e.g., PolynomialRegression(2) for a second order polynomial regression).\n\nA univariate mixture model is defined as:\n\ny_i(t) sim sum_k=1^K pi_k f(y_i(t)  t theta_k)\n\nwhere f(y_i(t)  t theta_k) is the density defined by the regression model (e.g., polynomial regression) with parameters theta_k, and pi_k are the mixture weights and t is time.\n\nExample\n\nCreating a univariate mixture model with 3 components, each a polynomial of degree 2:\n\ncomponent = PolynomialRegression(2)\nmodel = UnivariateMixtureModel(3, component)\n\n\n\n\n\n","category":"type"},{"location":"api/mixtures/#Multivariate-Mixture-Model","page":"Mixture Models","title":"Multivariate Mixture Model","text":"","category":"section"},{"location":"api/mixtures/","page":"Mixture Models","title":"Mixture Models","text":"The MultivariateMixtureModel is designed for clustering multivariate time series data. It consists of multiple component models, each representing a different cluster in the data. Each component model is a dictionary mapping variable names to their respective component models.","category":"page"},{"location":"api/mixtures/#TemporalMixtureModels.MultivariateMixtureModel","page":"Mixture Models","title":"TemporalMixtureModels.MultivariateMixtureModel","text":"Create a multivariate mixture model with n_components where each component is defined by the models passed in the components dictionary.\n\nArguments\n\nn_components::Int: Number of mixture components. \ncomponents::Dict{Symbol, <:AbstractMixtureModelComponent{T}}: A dictionary where keys are variable names (as Symbol) and values are instances of component models (e.g., PolynomialRegression(2) for a second order polynomial regression).\n\nIn this case, a multivariate mixture model is defined using independent components as:\n\n(y_i1 y_i2  y_iJ) sim sum_k=1^K pi_k prod_j = 1^J f_j(y_ij  t theta_kj)\n\nwhere f_j(y_ij  t theta_kj) is the density defined by the regression model for variable jwith parameters\\theta_{kj}, and\\pi_k` are the mixture weights.\n\nIt is assumed that the variables are independent given the component assignment, i.e., the joint density is the product of the individual densities.\n\nExample\n\nCreating a multivariate mixture model with 2 components, each a polynomial of degree 2 for variables :y and :z:\n\ncomponents = Dict(:y => PolynomialRegression(2), :z => PolynomialRegression(2))\nmodel = MultivariateMixtureModel(2, components)\n\n\n\n\n\n","category":"type"},{"location":"api/mixtures/#Predicting","page":"Mixture Models","title":"Predicting","text":"","category":"section"},{"location":"api/mixtures/","page":"Mixture Models","title":"Mixture Models","text":"Both UnivariateMixtureModel and MultivariateMixtureModel support making predictions at specified time points using the predict function.","category":"page"},{"location":"api/mixtures/#TemporalMixtureModels.predict-Union{Tuple{T}, Tuple{UnivariateMixtureModel{T}, AbstractVector{T}}} where T","page":"Mixture Models","title":"TemporalMixtureModels.predict","text":"Predict the values at given timepoints for each component of the mixture model for a univariate mixture model.\n\nArguments\n\nmodel::UnivariateMixtureModel{T}: The fitted mixture model.\ntimepoints::Vector{T}: A vector of timepoints at which to predict\n\nReturns\n\nA matrix of size (length(timepoints), n_components) where each column corresponds to the predictions from one component.\n\n\n\n\n\n","category":"method"},{"location":"api/mixtures/#TemporalMixtureModels.predict-Union{Tuple{T}, Tuple{MultivariateMixtureModel{T}, AbstractVector{T}}} where T","page":"Mixture Models","title":"TemporalMixtureModels.predict","text":"Predict the values at given timepoints for each component of the mixture model for a multivariate mixture model.\n\nArguments\n\nmodel::MultivariateMixtureModel{T}: The fitted mixture model.\ntimepoints::Vector{T}: A vector of timepoints at which to predict\n\nReturns\n\nA dictionary where keys are variable names (as Symbol) and values are matrices of size (length(timepoints), n_components) where each column corresponds to the predictions from one component for that variable.\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Getting Started","title":"Home","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"TemporalMixtureModels.jl is a small Julia package for fitting temporal mixture models to cluster time series data. The package supports both univariate and independent multivariate time series data. The package provides a simple API for fitting models, making predictions, and estimating uncertainty using bootstrap methods. ","category":"page"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Installation is straightforward in Julia:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"pkg> add TemporalMixtureModels","category":"page"},{"location":"#Temporal-Mixture-Models","page":"Getting Started","title":"Temporal Mixture Models","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"A temporal mixture model is a probabilistic model that assumes that the observed time series data is generated from a mixture of several underlying temporal processes. Each process is represented by a component model, and the overall model combines these components to explain the observed data. Temporal mixture models are particularly useful for clustering time series data, as they can capture the underlying patterns and variations in the data. The basic form of the temporal mixture model is","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"y_i(t) sim sum_k=1^K pi_k f_k(y_i(t)  x_t theta_k)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Here, f(y_i(t)  x_t theta_k) represents the component likelihood for the k-th component model, which describes the distribution of the observed value y_i(t) at time t given the input variable x_t and parameters theta_k. The mixture weights pi_k indicate the contribution of each component to the overall model, with the constraint that they sum to 1 (sum_k=1^K pi_k = 1). The number of components K is a hyperparameter that can be specified by the user. ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"In this package, the component likelihood is always based on a Gaussian zero-mean noise model, and the component models can be any regression model that fits within this framework. The main requirement for a component model is that it has a single explanatory variable (time) and produces a single output variable.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"For multivariate time series, the model assumes independence between each variable, leading to the following formulation:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"y_i(t) sim sum_k=1^K pi_k prod_j=1^J f_kj(y_ij(t)  x_t theta_kj)","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Temporal mixtures work exceptionally well when the time series are aligned, meaning that they share a common time axis and have similar lengths. This alignment allows the model to effectively learn the temporal patterns and relationships within the data. For unaligned time series, additional preprocessing steps such as dynamic time warping or interpolation may be necessary to align the data before applying temporal mixture models. ","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"While it is possible to implement custom component models, the package currently includes the following built-in models:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Polynomial regression\nRidge (L2) regression\nLasso (L1) regression","category":"page"},{"location":"#Notice","page":"Getting Started","title":"Notice","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The package is still wildly in development. Breaking changes will come.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"“Time, the devourer of all things,   and you, envious age, together you destroy all that is.”   — Ovid, Metamorphoses","category":"page"},{"location":"tutorials/univariate/#Univariate-Model","page":"Univariate","title":"Univariate Model","text":"","category":"section"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"This tutorial provides a step-by-step guide on how to use the TemporalMixtureModels.jl package to fit temporal mixture models to time series data. It provides a simple example using synthetic data to illustrate the main functionalities of the package, including data preparation, model fitting, prediction, and uncertainty estimation.","category":"page"},{"location":"tutorials/univariate/#Prerequisites","page":"Univariate","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"While the package uses an internal data structure for the time series data, the package by default implements automatic conversion from a DataFrame to its internal format. ","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"using TemporalMixtureModels, DataFrames","category":"page"},{"location":"tutorials/univariate/#Generating-Synthetic-Data","page":"Univariate","title":"Generating Synthetic Data","text":"","category":"section"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"For this tutorial, we will generate synthetic univariate time series data. The data will consist of three clusters, each generated from a different polynomial function with added Gaussian noise. The input DataFrame should be a so-called \"long\" format, with columns for the individual ID, time points, and observed values. ","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"# Set random seed for reproducibility\nusing Random\nRandom.seed!(1234)\n\n# Generate time points\nindividuals_per_group = [20, 30]\nt_values = 0:0.1:10\nn_groups = 2\n\ngroup_coefficients = [ [2.0, -0.5, 0.05],  # Group 1: y = 2 - 0.5*t + 0.05*t^2\n                       [1.0, 0.3, -0.02] ] # Group 2: y = 1 + 0.3*t - 0.02*t^2\n\nids = Int[]\ntimepoints = Float64[]\nmeasurements = Float64[]\nfor group in 1:n_groups\n    id_start = sum(individuals_per_group[1:group-1]) + 1\n    id_end = sum(individuals_per_group[1:group])\n    for individual in id_start:id_end\n        for t in t_values\n            y = group_coefficients[group][1] + group_coefficients[group][2]*t + group_coefficients[group][3]*t^2 + randn()*0.25\n            push!(ids, individual)\n            push!(timepoints, t)\n            push!(measurements, y)\n        end\n    end\nend\n\ninput_data = DataFrame(id = ids, time = timepoints, value = measurements)\nfirst(input_data, 5)  # Display the first 5 rows of the DataFrame","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"Here you can see the first few rows of the generated DataFrame. Each row corresponds to a measurement for a specific individual at a specific time point. The internal structure of the model takes care of the bookkeeping during the fitting process.","category":"page"},{"location":"tutorials/univariate/#Fitting-a-Temporal-Mixture-Model","page":"Univariate","title":"Fitting a Temporal Mixture Model","text":"","category":"section"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"Now that we have our synthetic data, we can fit a temporal mixture model using the fit! function. We will use a polynomial regression model as the component model for this example. We will specify the number of components (clusters) we expect in the data.","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"We first define the model, specifying the number of components and the type of component model to use. In this case, we will use a polynomial regression model of degree 2.","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"# Define the number of components and the component model\nn_components = 2\ncomponent_model = PolynomialRegression(2)\nmodel = UnivariateMixtureModel(n_components, component_model)","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"We can now fit the model to our data using the fit! function. This function takes the model and the input DataFrame as arguments and performs the fitting process.","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"# Fit the model to the data\nfit!(model, input_data)","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"We can also compute the confidence intervals for the model parameters using bootstrap resampling. This provides an estimate of the uncertainty in the parameter estimates.","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"# Compute bootstrap confidence intervals\nn_bootstrap = 100  # Number of bootstrap samples\nconfidence_intervals, _, _ = bootstrap_ci(model, input_data; n_bootstrap=n_bootstrap)\nconfidence_intervals","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"The output shows the confidence intervals for the parameters of each component model in the mixture. We can use these intervals and the fitted model to visualize the results.","category":"page"},{"location":"tutorials/univariate/","page":"Univariate","title":"Univariate","text":"using CairoMakie\n\n# Create a range of time points for prediction\nt_pred = 0:0.1:10\n\n# Prepare a figure\nfigure_mixture = let f = Figure()\n    ax = Axis(f[1, 1], xlabel=\"Time\", ylabel=\"Value\", title=\"Temporal Mixture Model Fit\")\n\n    # Plot the original data points\n    scatter!(ax, input_data.time, input_data.value; color=:gray, markersize=4, label=\"Data\")\n\n    # Plot the fitted component models\n    predictions = predict(model, t_pred)\n\n    COMPONENT_COLORS = [colorant\"#c74300\", colorant\"#008aa1\"]\n\n    for k in axes(predictions, 2)\n        lines!(ax, t_pred, predictions[:, k]; \n        label=\"Component $k\", color=COMPONENT_COLORS[k], linewidth=2)\n\n        # get the confidence bounds. This is still a bit clunky because there is no API for this yet\n        lower_bound_parameters = confidence_intervals[k][:lower]\n        upper_bound_parameters = confidence_intervals[k][:upper]\n\n        model_lb = PolynomialRegression(2, lower_bound_parameters)\n        model_ub = PolynomialRegression(2, upper_bound_parameters)\n\n        y_lower = predict(model_lb, t_pred)\n        y_upper = predict(model_ub, t_pred)\n\n        # Plot the confidence intervals as shaded areas\n        band!(ax, t_pred, y_lower, y_upper; \n        color=(COMPONENT_COLORS[k], 0.2), label=\"Component $k\")\n    end\n\n    axislegend(ax; merge=true)\n\n    f\nend\nfigure_mixture","category":"page"}]
}
