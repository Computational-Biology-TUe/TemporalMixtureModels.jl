var documenterSearchIndex = {"docs":
[{"location":"manual/custom_components/#Using-Custom-Model-Components","page":"Custom Model Components","title":"Using Custom Model Components","text":"In addition to the built-in component models provided by the TemporalMixtureModels.jl package, you can also define your own custom component models to use within the temporal mixture modeling framework. This allows you to tailor the modeling approach to the specific characteristics of your data and research questions. In this section, an example custom component model is implemented to illustrate how to create and use custom components. In this example, we will create an ExponentialDecay component model that fits an exponential decay function to the time series data.","category":"section"},{"location":"manual/custom_components/#Defining-a-Custom-Component-Model","page":"Custom Model Components","title":"Defining a Custom Component Model","text":"To define a custom component model, you need to create a new struct that inherits from the Component abstract type. You also need to implement the required methods for the component model, including initialize_parameters, n_parameters, predict, and fit!.","category":"section"},{"location":"manual/custom_components/#The-ExponentialDecay-Component","page":"Custom Model Components","title":"The ExponentialDecay Component","text":"The ExponentialDecay component model fits an exponential decay function of the form:\n\ny(t) = A cdot e^-B cdot t + C\n\nThe parameters of the model are A, B, and C, which represent the initial value, decay rate, and offset, respectively.\n\nusing TemporalMixtureModels, LinearAlgebra, CairoMakie\nimport TemporalMixtureModels: Component, initialize_parameters, n_parameters, predict, fit!\n\nstruct ExponentialDecay <: Component\n    # No additional fields needed for this simple model\nend\n\nfunction n_parameters(::ExponentialDecay)\n    return 3  # A, B, C\nend\n\nfunction initialize_parameters(::ExponentialDecay)\n    return randn(3) .* 0.1  # Small random initialization\nend\n\nfunction predict(::ExponentialDecay, params::AbstractVector, t::AbstractVector, inputs=nothing)\n    A, B, C = params\n    return A .* exp.(-B .* t) .+ C\nend\n\nThese are quite straightforward implementations. The n_parameters function returns the number of parameters in the model, initialize_parameters provides an initial guess for the parameters, and predict computes the predicted values given the parameters and time points. ","category":"section"},{"location":"manual/custom_components/#Model-Fitting","page":"Custom Model Components","title":"Model Fitting","text":"We also need to implement the fit! method to estimate the parameters from the data. Here, we will use a linearization approach to fit the exponential decay model. We need both an unweighted and a weighted version of the fit! function.\n\n\nfunction fit!(parameters::AbstractVector{T}, ::ExponentialDecay, t::AbstractVector{T}, y::AbstractVecOrMat{T}, ::Any) where T<:Real\n    # Linearize the model: y - C = A * exp(-B * t)\n    # Take logarithm: log(y - C) = log(A) - B * t\n    # This requires y > C, so we need to estimate C first\n    C_est = minimum(y) - 0.1  # Slightly below the minimum observed value\n    y_adjusted = y .- C_est\n    valid_mask = y_adjusted .> 0  # Only consider valid points for log\n    \n    if sum(valid_mask) < 2\n        error(\"Not enough valid data points to fit ExponentialDecay model.\")\n    end\n    \n    log_y = log.(y_adjusted[valid_mask])\n    t_valid = t[valid_mask]\n    \n    # Fit linear model: log_y = log(A) - B * t_valid\n    X = hcat(ones(length(t_valid)), -t_valid)\n    coeffs = X \\ log_y\n    \n    A_est = exp(coeffs[1])\n    B_est = coeffs[2]\n    \n    parameters[1] = A_est\n    parameters[2] = B_est\n    parameters[3] = C_est\nend\n\nfunction fit!(parameters::AbstractVector{T}, ::ExponentialDecay, t::AbstractVector{T}, y::AbstractVecOrMat{T}, w::AbstractVector{T}, ::Any) where T<:Real\n\n    C_est = minimum(y) - 0.1  # Slightly below the minimum observed value\n    y_adjusted = y .- C_est\n    valid_mask = (y_adjusted .> 0) .& (w .> 0)  # Only consider valid points for log and positive weights\n    if sum(valid_mask) < 2\n        error(\"Not enough valid data points to fit ExponentialDecay model.\")\n    end\n\n    log_y = log.(y_adjusted[valid_mask])\n    t_valid = t[valid_mask]\n    w_valid = w[valid_mask]\n\n    # Fit weighted linear model: log_y = log(A) - B * t_valid\n    X = hcat(ones(length(t_valid)), -t_valid)\n    W = Diagonal(w_valid)\n    coeffs = (X' * W * X) \\ (X' * W * log_y)\n\n    A_est = exp(coeffs[1])\n    B_est = coeffs[2]\n    parameters[1] = A_est\n    parameters[2] = B_est\n    parameters[3] = C_est\n\nend","category":"section"},{"location":"manual/custom_components/#Using-the-Custom-Component-Model","page":"Custom Model Components","title":"Using the Custom Component Model","text":"Once you have defined your custom component model, you can use it in the same way as the built-in component models. Here is an example of how to fit a temporal mixture model using the ExponentialDecay component:\n\nusing TemporalMixtureModels, Random\nRandom.seed!(27052023)  # For reproducibility\n\n# Generate synthetic data\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)\n\n# Define the custom component model\ncomponent_model = ExponentialDecay()\nnum_components = 2  # For example, we want to fit 2 clusters\nmodel = fit_mixture(component_model, num_components, t, y[:, 1], ids)\n\nThis will fit a temporal mixture model with 2 ExponentialDecay components to the systolic blood pressure data. You can then make predictions and analyze the fitted model as usual.\n\nWe can use the fitted model to make predictions for new time points:\n\nnew_time_points = 0:0.1:5.0\npredictions = predict(model, new_time_points)\n\nfigure_predictions = Figure(size=(350,250)) # hide\nax_predictions = Axis(figure_predictions[1, 1]; xlabel=\"Time (hours)\", ylabel=\"Systolic BP (mmHg)\") # hide\ncolors = Makie.wong_colors() # hide\nscatter!(ax_predictions, t, y[:, 1]; color=:black, markersize=4, label=\"Data\") # hide\nfor k in 1:num_components # hide\n    lines!(ax_predictions, new_time_points, predictions[k]; color=colors[k], # hide\n              linewidth=2, label=\"Component $k\") # hide\nend # hide\naxislegend(ax_predictions; position=:lb, merge=true) # hide\n\nsave(\"systolic_bp_custom.png\", figure_predictions) # hide\n\n(Image: systolic_bp_custom)","category":"section"},{"location":"manual/evaluation_metrics/#Evaluation-Metrics","page":"Evaluation Metrics","title":"Evaluation Metrics","text":"Within the package, three primary evaluation metrics are implemented to assess the performance of fitted temporal mixture models: Akaike Information Criterion (AIC), Bayesian Information Criterion (BIC), and Log-Likelihood. These metrics provide insights into the goodness-of-fit of the models while accounting for model complexity.","category":"section"},{"location":"manual/evaluation_metrics/#TemporalMixtureModels.loglikelihood-Union{Tuple{Y}, Tuple{T}, Tuple{MixtureResult, AbstractVector{T}, AbstractMatrix{Y}, AbstractVector{Int64}}} where {T<:Real, Y<:Union{Missing, Real}}","page":"Evaluation Metrics","title":"TemporalMixtureModels.loglikelihood","text":"loglikelihood(result::MixtureResult, t::AbstractVector{T}, y::AbstractMatrix{Y}, ids::AbstractVector{Int}; inputs=nothing) where {T<:Real, Y<:Union{Real, Missing}}\n\nCompute the total log-likelihood of the fitted mixture model on the given data.\n\nArguments\n\nresult::MixtureResult: The result of fitting the mixture model.\nt::AbstractVector: Time points of the observations.\ny::AbstractMatrix: Observed data (vector or matrix).\nids::AbstractVector{Int}: Cluster assignments for each observation.\ninputs: Optional additional inputs for prediction.\n\nReturns\n\nFloat64: The total log-likelihood of the model on the data.\n\n\n\n\n\n","category":"method"},{"location":"manual/evaluation_metrics/#TemporalMixtureModels.aic","page":"Evaluation Metrics","title":"TemporalMixtureModels.aic","text":"aic(result::MixtureResult, t::AbstractVector{T}, y::AbstractMatrix{Y}, ids::AbstractVector{Int}; inputs=nothing) where {T<:Real, Y<:Union{Real, Missing}}\n\nCompute the Akaike information criterion of the fitted mixture model on the given data.\n\nArguments\n\nresult::MixtureResult: The result of fitting the mixture model.\nt::AbstractVector: Time points of the observations.\ny::AbstractMatrix: Observed data (vector or matrix).\nids::AbstractVector{Int}: Cluster assignments for each observation.\ninputs: Optional additional inputs for prediction.\n\nReturns\n\nFloat64: The Akaike information criterion of the model on the data.\n\n\n\n\n\n","category":"function"},{"location":"manual/evaluation_metrics/#TemporalMixtureModels.bic","page":"Evaluation Metrics","title":"TemporalMixtureModels.bic","text":"bic(result::MixtureResult, t::AbstractVector{T}, y::AbstractMatrix{Y}, ids::AbstractVector{Int}; inputs=nothing) where {T<:Real, Y<:Union{Real, Missing}}\n\nCompute the Bayesian information criterion of the fitted mixture model on the given data.\n\nArguments\n\nresult::MixtureResult: The result of fitting the mixture model.\nt::AbstractVector: Time points of the observations.\ny::AbstractMatrix: Observed data (vector or matrix).\nids::AbstractVector{Int}: Cluster assignments for each observation.\ninputs: Optional additional inputs for prediction.\n\nReturns\n\nFloat64: The Bayesian information criterion of the model on the data.\n\n\n\n\n\n","category":"function"},{"location":"manual/regularized_regression/#Regularized-Regression-Components","page":"Regularized Regression Components","title":"Regularized Regression Components","text":"The TemporalMixtureModels.jl package includes support for regularized regression components, specifically Ridge Regression and Lasso Regression. These components are useful when dealing with multicollinearity or when you want to perform variable selection in your regression models. The regularized regression components extend the basic polynomial regression model by adding a penalty term to the loss function.","category":"section"},{"location":"manual/regularized_regression/#TemporalMixtureModels.RidgeRegression","page":"Regularized Regression Components","title":"TemporalMixtureModels.RidgeRegression","text":"RidgeRegression(degree::Int, λ::Real)\n\nPolynomial regression component model with L2 regularization penalization (Ridge regression).\n\nArguments\n\ndegree: Polynomial degree (e.g., 2 for quadratic)\nλ: Regularization strength (non-negative)\n\n\n\n\n\n","category":"type"},{"location":"manual/regularized_regression/#TemporalMixtureModels.LassoRegression","page":"Regularized Regression Components","title":"TemporalMixtureModels.LassoRegression","text":"LassoRegression(degree::Int, λ::Real)\n\nPolynomial regression component model with L1 regularization penalization (Lasso regression).\n\nArguments\n\ndegree: Polynomial degree (e.g., 2 for quadratic)\nλ: Regularization strength (non-negative)\n\n\n\n\n\n","category":"type"},{"location":"manual/bootstrap/#Bootstrapping-for-Uncertainty-Estimation","page":"Bootstrapping for Uncertainty Estimation","title":"Bootstrapping for Uncertainty Estimation","text":"TemporalMixtureModels.jl provides functionality to perform bootstrapping to estimate the uncertainty of the fitted model parameters. Bootstrapping involves resampling the data with replacement and refitting the model multiple times to obtain a distribution of parameter estimates.","category":"section"},{"location":"manual/bootstrap/#Performing-Bootstrapping","page":"Bootstrapping for Uncertainty Estimation","title":"Performing Bootstrapping","text":"To perform bootstrapping with TemporalMixtureModels.jl, you can use the bootstrap function. This function works in the same way as the fit_mixture function, but it takes an additional argument specifying the number of bootstrap samples to generate.\n\nThe bootstrap function returns a vector of fitted mixture models, each corresponding to a bootstrap sample. We can then predict using each of these models to obtain a distribution of predictions, which can then also be used to estimate confidence intervals.","category":"section"},{"location":"manual/bootstrap/#TemporalMixtureModels.bootstrap","page":"Bootstrapping for Uncertainty Estimation","title":"TemporalMixtureModels.bootstrap","text":"bootstrap(component::Component, n_components::Int, n_bootstrap::Int, \nt::AbstractVector, y::AbstractMatrix, ids::AbstractVector;\nn_repeats::Int=5,\nerror_model::ErrorModel=NormalError(),\ninputs=nothing,\nmax_iter::Int=100,\ntol::Float64=1e-6,\nseparation_threshold::Float64=0.01,\nrng::AbstractRNG=Random.GLOBAL_RNG,\nshow_progress_bar::Bool=true)\n\nRun bootstrap resampling to estimate confidence intervals for the coefficients of each component in a mixture model. The function fits the mixture model multiple times on bootstrap samples drawn with replacement from the original data. After fitting, it matches the components to the original fit to prevent label switching and collects the parameter estimates. Separation scores are computed to detect ambiguities in component matching, which may indicate unreliable confidence intervals. This can happen if the components aren't well separated, for example when too many components are specified.\n\nArguments\n\ncomponent::Component: The component model to use (e.g., PolynomialRegression).\nn_components::Int: Number of mixture components (clusters).\nn_bootstrap::Int: Number of bootstrap samples to draw.\nt::AbstractVector: Time points vector.\ny::AbstractMatrix: Observations matrix (rows: time points, columns: measurements).\nids::AbstractVector: Subject IDs vector.\n\nOptional keyword arguments\n\nn_repeats::Int=5: Number of random initializations for fitting.\nerror_model::ErrorModel=NormalError(): Error model to use. Only NormalError is currently supported.\ninputs=nothing: Additional inputs for the component model (if applicable).\nmax_iter::Int=100: Maximum number of EM iterations.\ntol::Float64=1e-6: Convergence tolerance for the EM algorithm.\nseparation_threshold::Float64=0.01: Threshold for detecting ambiguities in component matching.\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator to use.\nshow_progress_bar::Bool=true: Whether to show a progress bar.\n\nReturns\n\nbootstrap_results::Vector{MixtureResult}: A vector of MixtureResult objects from each bootstrap sample.\nambiguities_detected::Int: The number of ambiguities detected during component matching in the bootstrap resampling. A high number may indicate unreliable confidence intervals due to uncertain sample assignment to components.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Basic-Usage-of-TemporalMixtureModels.jl","page":"Basic Usage","title":"Basic Usage of TemporalMixtureModels.jl","text":"The main functionality revolves around the fit_mixture function, which fits a temporal mixture model to the provided time series data, using the EM algorithm.\n\nFirst, we need to import the package:\n\nusing TemporalMixtureModels, Random\nRandom.seed!(27052023)  # For reproducibility","category":"section"},{"location":"manual/usage/#Data-Preparation","page":"Basic Usage","title":"Data Preparation","text":"First of all, you'll need some data that is in the right format. The basic format for the data consists of three elements:\n\nt: A vector of time points. This should be a one-dimensional array of real numbers representing the time axis for the time series data.\nY: A vector or matrix of observed values. Each row corresponds to a time point in t, and each column corresponds to a different outcome variable (for multivariate time series). For univariate time series, this can be a one-dimensional array.\nids: A vector of identifiers for each independent time series. The length of this vector should match the number of rows in Y and indicates which time series each observation belongs to.\n\nOptionally, you can also provide:\n\ninputs: A matrix of input variables (covariates) that may influence the observed values. Each row corresponds to a time point, and each column corresponds to a different input variable. Inputs are currently not used in the built-in component models, but the support is there for custom models.\n\nSay, we have a dataset with blood pressure measurements over time for multiple patients while they have been given either a placebo or a drug. Our table of data might look like this:\n\nid time systolic_pressure diastolic_pressure treatment\n1 0.0 120 80 drug\n1 1.0 118 78 drug\n1 2.0 115 75 drug\n2 0.0 130 85 placebo\n2 1.0 128 83 placebo\n2 2.0 125 80 placebo\n... ... ... ... ...\n43 2.0 110 70 placebo\n\nFor the examples in the manual, the package contains a function called example_bp_data() that can be used to generate a dataset like this.\n\nLet's generate the example blood pressure dataset:\n\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)\n\nWe can quickly visualize the systolic blood pressure measurements over time for all subjects:\n\nusing CairoMakie, Random\nusing TemporalMixtureModels: example_bp_data\n\nRandom.seed!(27052023)\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)\nfig_bp = Figure(size=(350,250))\nax_bp = Axis(fig_bp[1, 1]; xlabel=\"Time (hours)\", ylabel=\"Systolic BP (mmHg)\")\nfor subject_id in unique(ids)\n    mask = ids .== subject_id\n    t_view = t[mask]\n    y_view = y[mask, 1] # Systolic pressure is the first column\n    label = class_labels[mask][1]\n    descr = label == 1 ? \"Drug\" : \"Placebo\"\n    lines!(ax_bp, t_view, y_view, label=descr, color=label == 1 ? Makie.wong_colors()[1] : Makie.wong_colors()[2], alpha=0.5)\nend\n\naxislegend(ax_bp; merge=true, position=:lb)\n\nsave(\"systolic_bp_plot.png\", fig_bp)\n\nnothing\n\n(Image: systolic_bp_plot)\n\nnote: Missing Data\nIt may occur that some time series have missing values at certain time points. The current implementation of fit_mixture handles missing data by ignoring those specific observations during the fitting process. This may for example also happen if you measure two variables that are not always both measured at the same time points. In that case, you can fill the missing values with missing and the fitting process will skip those values. TemporalMixtureModels.jl is designed to handle such cases gracefully.An example of such a dataset, where we may measure systolic pressure at the start and after 1 hour, while we diastolic pressure at the start and at 2 hours, would look like this:id time systolic_pressure diastolic_pressure treatment\n1 0.0 120 80 drug\n1 1.0 118 missing drug\n1 2.0 missing 75 drug\n2 0.0 130 85 placebo\n2 1.0 128 missing placebo\n2 2.0 missing 80 placebo\n... ... ... ... ...\n43 2.0 missing 70 placeboAs long as we have enough data points overall, the fitting process will still work.","category":"section"},{"location":"manual/usage/#Fitting-a-Temporal-Mixture-Model","page":"Basic Usage","title":"Fitting a Temporal Mixture Model","text":"Once you have your data prepared, you can fit a temporal mixture model using the fit_mixture function. You need to specify the number of components (clusters) you want to fit, as well as the component model to use (e.g., PolynomialRegression). For now, we are interested in the systolic pressure only, so we will extract that column from Y for fitting.\n\ncomponent_model = PolynomialRegression(2)\nnum_components = 2  # For example, we want to fit 2 clusters\nmodel = fit_mixture(component_model, num_components, t, y[:, 1], ids)\n\nThis will fit a temporal mixture model with 2 polynomial regression components of degree 2 to the systolic blood pressure data. ","category":"section"},{"location":"manual/usage/#The-Polynomial-Regression-Component","page":"Basic Usage","title":"The Polynomial Regression Component","text":"The PolynomialRegression component model fits a polynomial regression of a specified degree to the time series data. In this example, we used a polynomial of degree 2, which means that each component will fit a quadratic curve to the data. You can choose different degrees based on the complexity of the temporal patterns you expect in your data.","category":"section"},{"location":"manual/usage/#Customizing-the-fitting-process","page":"Basic Usage","title":"Customizing the fitting process","text":"The fit_mixture function provides several optional keyword arguments to customize the fitting process:","category":"section"},{"location":"manual/usage/#Making-Predictions","page":"Basic Usage","title":"Making Predictions","text":"After fitting the model, you can make predictions for new time points using the predict function. You can specify the time points at which you want predictions, and the function will return the predicted values for each component.\n\nnew_time_points = 0:0.1:2.0\npredictions = predict(model, new_time_points)\n\nAn example of the resulting mixture model is shown below:\n\nusing CairoMakie, Random\nusing TemporalMixtureModels\n\nRandom.seed!(27052023)\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)\ncomponent_model = PolynomialRegression(2)\nnum_components = 2\nmodel = fit_mixture(component_model, num_components, t, y[:, 1], ids)\n\nnew_time_points = 0:0.1:5.0\npredictions = predict(model, new_time_points)\n\nfigure_predictions = Figure(size=(350,250))\nax_predictions = Axis(figure_predictions[1, 1]; xlabel=\"Time (hours)\", ylabel=\"Systolic BP (mmHg)\")\ncolors = Makie.wong_colors()\nscatter!(ax_predictions, t, y[:, 1]; color=:black, markersize=4, label=\"Data\")\nfor k in 1:num_components\n    lines!(ax_predictions, new_time_points, predictions[k]; color=colors[k],\n              linewidth=2, label=\"Component $k\")\nend\naxislegend(ax_predictions; position=:lb, merge=true)\n\nsave(\"systolic_bp_mixture_model.png\", figure_predictions)\n\n(Image: systolic_bp_mixture_model)","category":"section"},{"location":"manual/usage/#TemporalMixtureModels.example_bp_data","page":"Basic Usage","title":"TemporalMixtureModels.example_bp_data","text":"example_bp_data(;n_subjects_drug=50, n_subjects_placebo=50, n_timepoints=5, rng::AbstractRNG=Random.GLOBAL_RNG)\n\nGenerate example blood pressure data for testing and examples.\n\nArguments\n\nn_subjects_drug: Number of subjects in the drug group (default: 50)\nn_subjects_placebo: Number of subjects in the placebo group (default: 50)\nn_timepoints: Number of time points per subject (default: 5)\nrng: Random number generator (default: Random.GLOBAL_RNG)\n\nReturns\n\nt: Vector of time points\ny: Matrix of blood pressure measurements (systolic and diastolic)\nids: Vector of subject IDs\nclass_labels: Vector of class labels (1 for drug, 0 for placebo)\n\nExample\n\nusing TemporalMixtureModels: example_bp_data\nt, y, ids, class_labels = example_bp_data(n_subjects_drug=30, n_subjects_placebo=30, n_timepoints=4)\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#TemporalMixtureModels.PolynomialRegression","page":"Basic Usage","title":"TemporalMixtureModels.PolynomialRegression","text":"PolynomialRegression(degree::Int)\n\nPolynomial regression component model.\n\nArguments\n\ndegree: Polynomial degree (e.g., 2 for quadratic)\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#TemporalMixtureModels.fit_mixture","page":"Basic Usage","title":"TemporalMixtureModels.fit_mixture","text":"fit_mixture(component, n_components, t, y, ids;\n            n_repeats=5, error_model=NormalError(), inputs=nothing, \n            max_iter=100, tol=1e-6, verbose=true)\n\nFit a mixture model using the Expectation-Maximization (EM) algorithm. By default, fit_mixture will run 5 EM restarts and return the best fitting model based on log-likelihood.\n\nArguments\n\ncomponent: A Component model (e.g., PolynomialRegression(2))\nn_components: Number of mixture components/clusters\nt: Time points (vector)\ny: Measurements (vector for single measurement, matrix for multiple)\nids: Subject identifiers (vector)\n\nKeyword Arguments\n\nn_repeats: Number of EM restarts (default: 5)\nerror_model: Error distribution (currently only NormalError() is supported, included for possible future extensions)\ninputs: Additional input variables to be passed to the component model (default: nothing)\nmax_iter: Maximum EM iterations (default: 100)\ntol: Convergence tolerance (default: 1e-6)\nverbose: Print progress (default: true)\n\nReturns\n\nMixtureResult containing fitted parameters and cluster assignments, with fields:\ncomponent: The component model used\nn_clusters: Number of clusters\nparameters: Fitted parameters for each cluster\nparams_error: Estimated error model parameters for each measurement and cluster\ncluster_probs: Mixing proportions for each cluster\nresponsibilities: Posterior responsibilities for each subject and cluster\nloglikelihood: Final log-likelihood of the fitted model\nconverged: Boolean indicating if the EM algorithm converged\nn_iterations: Number of iterations performed\nerror_model: The error model used\n\nExamples\n\n# Single measurement with normal errors\nresult = fit_mixture(PolynomialRegression(2), 3, t, y, ids)\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"Home","text":"compat: Version 2.0 Notice\nThe upgrade from version 1.x to 2.x includes a complete redesign of the API. It is recommended to upgrade to the latest version to benefit from new features and improvements.\n\nTemporalMixtureModels.jl is a small Julia package for fitting temporal mixture models to cluster time series data. The package supports both univariate and independent multivariate time series data. The package provides a simple API for fitting models, making predictions, and estimating uncertainty using bootstrap methods. ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Installation is straightforward in Julia:\n\npkg> add TemporalMixtureModels","category":"section"},{"location":"#Temporal-Mixture-Models","page":"Home","title":"Temporal Mixture Models","text":"A temporal mixture model is a probabilistic model that assumes that the observed time series data is generated from a mixture of several underlying temporal processes. Each process is represented by a component model, and the overall model combines these components to explain the observed data. Temporal mixture models are particularly useful for clustering time series data, as they can capture the underlying patterns and variations in the data. The basic form of the temporal mixture model is\n\ny_i(t) sim sum_k=1^K pi_k f_k(y_i(t)  x_t theta_k)\n\nHere, f(y_i(t)  x_t theta_k) represents the component likelihood for the k-th component model, which describes the distribution of the observed value y_i(t) at time t given the input variable x_t and parameters theta_k. The mixture weights pi_k indicate the contribution of each component to the overall model, with the constraint that they sum to 1 (sum_k=1^K pi_k = 1). The number of components K is a hyperparameter that can be specified by the user. \n\nIn this package, the component likelihood is always based on a Gaussian zero-mean noise model, and the component models can be any regression model that fits within this framework. The main requirement for a component model is that it has a single explanatory variable (time) and produces a single output variable.\n\nFor multivariate time series, the model assumes independence between each variable, leading to the following formulation:\n\ny_i(t) sim sum_k=1^K pi_k prod_j=1^J f_kj(y_ij(t)  x_t theta_kj)\n\nTemporal mixtures work exceptionally well when the time series are aligned, meaning that they share a common time axis and have similar lengths. This alignment allows the model to effectively learn the temporal patterns and relationships within the data. For unaligned time series, additional preprocessing steps such as dynamic time warping or interpolation may be necessary to align the data before applying temporal mixture models. \n\nWhile it is possible to implement custom component models, the package currently includes the following built-in models:\n\nPolynomial regression\nRidge (L2) regression\nLasso (L1) regression","category":"section"},{"location":"#Notice","page":"Home","title":"Notice","text":"The package is still wildly in development. Breaking changes will come.\n\n“Time, the devourer of all things,   and you, envious age, together you destroy all that is.”   — Ovid, Metamorphoses","category":"section"},{"location":"manual/multivariate/#Multiple-Output-Variables","page":"Multiple Output Variables","title":"Multiple Output Variables","text":"TemporalMixtureModels.jl supports fitting mixture models to multivariate time series data with multiple output variables. Each output variable is modeled independently, within the same mixture component. This means that for each component in the mixture model, there is a separate set of parameters for each output variable, allowing the model to capture different temporal patterns for each variable, but also to capture different combinations of patterns across variables in separate mixture components.\n\nusing TemporalMixtureModels, Random\nRandom.seed!(27052023)  # For reproducibility","category":"section"},{"location":"manual/multivariate/#Data-Preparation","page":"Multiple Output Variables","title":"Data Preparation","text":"When preparing your data for multivariate time series modeling, the format is similar to that of univariate time series, with the key difference being that the observed values Y should be a matrix where each column corresponds to a different output variable. Each row still corresponds to a time point in t, and the ids vector indicates which time series each observation belongs to. \n\nThe example dataset provided by the example_bp_data() function includes two output variables: systolic and diastolic blood pressure measurements. You can use this function to generate a multivariate dataset as follows:\n\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)","category":"section"},{"location":"manual/multivariate/#Defining-a-Composite-Component-Model","page":"Multiple Output Variables","title":"Defining a Composite Component Model","text":"As the PolynomialRegression component only supports a single output variable, we need to define a composite component model that combines multiple PolynomialRegression models, one for each output variable. Creation of a composite component model is very straightforward using the @component macro.\n\ncomponent_model = @component begin\n    y[1] ~ PolynomialRegression(2)\n    y[2] ~ PolynomialRegression(2)\nend\n\nThis composite model specifies that the first output variable (y[1], systolic pressure) is modeled using a polynomial regression of degree 2, and the second output variable (y[2], diastolic pressure) is also modeled using a polynomial regression of degree 2. The @component macro is sufficiently flexible to allow for different types of component models for each output variable if desired. ","category":"section"},{"location":"manual/multivariate/#Fitting-the-Multivariate-Temporal-Mixture-Model","page":"Multiple Output Variables","title":"Fitting the Multivariate Temporal Mixture Model","text":"Once you have defined your composite component model, you can fit the multivariate temporal mixture model using the fit_mixture function, just like in the univariate case. You need to specify the number of components (clusters) you want to fit, as well as the composite component model to use.\n\nnum_components = 2  # For example, we want to fit 2 clusters\nmodel = fit_mixture(component_model, num_components, t, y, ids)\n\nThis will fit a temporal mixture model with 2 components, each consisting of two polynomial regression models (one for each output variable) of degree 2 to the multivariate blood pressure data. \n\nWe can now use the fitted model to make predictions for new time points, just like in the univariate case. \n\nAn example of the resulting mixture model is shown below:\n\nusing CairoMakie, Random\nusing TemporalMixtureModels\n\nRandom.seed!(27052023)\nt, y, ids, class_labels = example_bp_data(;n_subjects_drug=21, n_subjects_placebo=22, n_timepoints=5)\ncomponent_model = @component begin\n    y[1] ~ PolynomialRegression(2)\n    y[2] ~ PolynomialRegression(2)\nend\nnum_components = 2\nmodel = fit_mixture(component_model, num_components, t, y, ids)\n\nnew_time_points = 0:0.1:5.0\npredictions = predict(model, new_time_points)\n\nfigure_predictions = Figure(size=(750, 350))\nax_predictions = Axis(figure_predictions[1, 1]; xlabel=\"Time (hours)\", ylabel=\"Systolic BP (mmHg)\")\nax_diastolic = Axis(figure_predictions[1, 2]; xlabel=\"Time (hours)\", ylabel=\"Diastolic BP (mmHg)\")\ncolors = Makie.wong_colors()\nscatter!(ax_predictions, t, y[:, 1]; color=:black, markersize=4, label=\"Data\")\nscatter!(ax_diastolic, t, y[:, 2]; color=:black, markersize=4, label=\"Data\")\nfor k in 1:num_components\n    lines!(ax_predictions, new_time_points, predictions[k][:, 1]; color=colors[k],\n              linewidth=2, label=\"Component $k\")\n    lines!(ax_diastolic, new_time_points, predictions[k][:, 2]; color=colors[k],\n              linewidth=2, label=\"Component $k\")\nend\naxislegend(ax_predictions; position=:lb, merge=true)\n\nsave(\"multivariate_mixture_model.png\", figure_predictions)\n\n(Image: Multivariate Mixture Model)","category":"section"},{"location":"manual/multivariate/#TemporalMixtureModels.@component","page":"Multiple Output Variables","title":"TemporalMixtureModels.@component","text":"@component begin ... end\n\nThe @component macro allows defining a CompositeComponent in a concise way. We use composite components to connect component models to specific measurements in multivariate data. Each line inside the begin ... end block should specify a mapping from a measurement (or range of measurements) to a component model using the syntax \n\ny[index] ~ ComponentModel(args...)\n\nAll indices refer to the columns of the observation matrix y. The macro collects all specified components and their corresponding measurement indices, and constructs a CompositeComponent instance. The resulting CompositeComponent can then be used in mixture model fitting, in the same way as regular components.\n\nExample\n\nSimple Composite Component\n\nusing TemporalMixtureModels\n\ncomponent = @component begin\n    y[1] ~ PolynomialRegression(2)  # Quadratic for measurement 1\n    y[2] ~ PolynomialRegression(3)  # Cubic for measurement 2\nend\n\nComposite Component with Ranges\n\nWhile the PolynomialRegression component only models a single measurement, you can also use components that model multiple measurements at once. For example, if you have a bivariate measurement that you want to model with a single component (here abstracted as BivariateComponent), you can specify a range of indices:\n\nusing TemporalMixtureModels\n\ncomponent = @component begin\n    y[1] ~ PolynomialRegression(2)  # Quadratic for measurement 1\n    y[2:3] ~ BivariateComponent()  # A bivariate component for measurements 2 and 3\nend\n\n\n\n\n\n","category":"macro"}]
}
